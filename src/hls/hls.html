<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC Stream to HLS</title>
</head>
<body>
<h1>WebRTC Stream to HLS</h1>
<video id="localVideo" autoplay muted playsinline></video>
<button id="startStream">Start Streaming</button>
<button id="stopStream" disabled>Stop Streaming</button>

<script>
  const startButton = document.getElementById('startStream');
  const stopButton = document.getElementById('stopStream');
  const localVideo = document.getElementById('localVideo');

  let mediaStream = null;
  // let peerConnection = null;

  // async function startStreaming() {
  //   try {
  //     // Get local media stream (camera and microphone)
  //     mediaStream = await navigator.mediaDevices.getUserMedia({
  //       video: true,
  //       audio: true
  //     });
  //     localVideo.srcObject = mediaStream;
  //
  //     // Create WebRTC connection
  //     peerConnection = new RTCPeerConnection({
  //       iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
  //     });
  //
  //     // Handle ICE candidates and send them to the server
  //     peerConnection.onicecandidate = event => {
  //       if (event.candidate) {
  //         // Send the ICE candidate to the server
  //         fetch('http://localhost:3000/hls/candidate', {
  //           method: 'POST',
  //           headers: { 'Content-Type': 'application/json' },
  //           body: JSON.stringify({ candidate: event.candidate })
  //         });
  //       }
  //     };
  //
  //     // Log ICE connection state changes
  //     peerConnection.oniceconnectionstatechange = () => {
  //       console.log('ICE Connection State:', peerConnection.iceConnectionState);
  //     };
  //
  //     // Add each track to the RTCPeerConnection
  //     mediaStream.getTracks().forEach(track => {
  //       peerConnection.addTrack(track, mediaStream);
  //     });
  //
  //     // Create an offer and set it as the local description
  //     const offer = await peerConnection.createOffer();
  //     await peerConnection.setLocalDescription(offer);
  //
  //     // Send offer to server
  //     const response = await fetch('http://localhost:3000/hls/start', {
  //       method: 'POST',
  //       headers: { 'Content-Type': 'application/json' },
  //       body: JSON.stringify({ sdp: offer.sdp })
  //     });
  //
  //     const { sdp: answerSdp } = await response.json();
  //     const answer = new RTCSessionDescription({
  //       type: 'answer',
  //       sdp: answerSdp
  //     });
  //
  //     // Set the remote description with the server's answer
  //     await peerConnection.setRemoteDescription(answer);
  //
  //     console.log('Streaming started');
  //     startButton.disabled = true;
  //     stopButton.disabled = false;
  //
  //   } catch (error) {
  //     console.error('Error starting stream:', error);
  //   }
  // }

  let peerConnection = new RTCPeerConnection({
    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
  });

  async function startStreaming() {
    const mediaStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    mediaStream.getTracks().forEach(track => peerConnection.addTrack(track, mediaStream));

    // Create an offer and set it as the local description
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);

    // Send the offer SDP with fingerprint to the server
    const response = await fetch('http://localhost:3000/webrtc/start', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ sdp: peerConnection.localDescription.sdp })
    });

    const { sdp: answerSdp } = await response.json();
    await peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: answerSdp }));
  }

  function stopStreaming() {
    try {
      // Close peer connection and stop media stream
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }

      if (mediaStream) {
        mediaStream.getTracks().forEach(track => track.stop());
        mediaStream = null;
      }

      console.log('Streaming stopped');
      startButton.disabled = false;
      stopButton.disabled = true;

    } catch (error) {
      console.error('Error stopping stream:', error);
    }
  }

  startButton.addEventListener('click', startStreaming);
  stopButton.addEventListener('click', stopStreaming);
</script>
</body>
</html>